-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- PROFILES
CREATE TABLE IF NOT EXISTS profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  first_name TEXT,
  last_name TEXT,
  title TEXT,
  email TEXT,
  phone TEXT,
  location TEXT,
  timezone TEXT,
  company TEXT,
  website TEXT,
  linkedin TEXT,
  twitter TEXT,
  bio TEXT,
  avatar_url TEXT,
  joined_date TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  completion_percentage INTEGER DEFAULT 0,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- FAMILIES
CREATE TABLE IF NOT EXISTS families (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  advisor_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  wealth TEXT,
  members_count INTEGER DEFAULT 0,
  role TEXT DEFAULT 'consultant', -- 'external-consul', 'consultant', 'personal-advisor'
  payment_status TEXT DEFAULT 'pending', -- 'paid', 'pending', 'no-invoices'
  status TEXT DEFAULT 'active', -- 'active', 'pending', 'inactive'
  last_contact TIMESTAMP WITH TIME ZONE,
  industry TEXT,
  location TEXT,
  email TEXT,
  phone TEXT,
  description TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- FAMILY MEMBERS
CREATE TABLE IF NOT EXISTS family_members (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  family_id BIGINT REFERENCES families(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  role TEXT,
  email TEXT,
  avatar TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- TASKS
CREATE TABLE IF NOT EXISTS tasks (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  family_id BIGINT REFERENCES families(id) ON DELETE CASCADE,
  advisor_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  due_date TIMESTAMP WITH TIME ZONE,
  priority TEXT DEFAULT 'medium', -- 'low', 'medium', 'high'
  completed BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- SERVICES
CREATE TABLE IF NOT EXISTS services (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  family_id BIGINT REFERENCES families(id) ON DELETE CASCADE,
  advisor_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  status TEXT DEFAULT 'Pending', -- 'Active', 'In Progress', 'Pending'
  progress INTEGER DEFAULT 0,
  price TEXT,
  start_date TIMESTAMP WITH TIME ZONE,
  description TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- CONSULTATIONS
CREATE TABLE IF NOT EXISTS consultations (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  family_id BIGINT REFERENCES families(id) ON DELETE CASCADE,
  advisor_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  date DATE,
  time TEXT,
  status TEXT DEFAULT 'scheduled', -- 'scheduled', 'completed', 'cancelled'
  meeting_link TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- CONSULTATION MEMBERS (Link table)
CREATE TABLE IF NOT EXISTS consultation_members (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  consultation_id BIGINT REFERENCES consultations(id) ON DELETE CASCADE,
  family_member_id BIGINT REFERENCES family_members(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- CREDENTIALS
CREATE TABLE IF NOT EXISTS credentials (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  advisor_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  issuer TEXT,
  year TEXT,
  status TEXT DEFAULT 'pending',
  credential_id TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- EXPERTISE
CREATE TABLE IF NOT EXISTS expertise (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  advisor_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  area TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- NOTIFICATIONS
CREATE TABLE IF NOT EXISTS notifications (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  type TEXT, -- 'message', 'alert', 'update', 'reminder'
  title TEXT NOT NULL,
  description TEXT,
  read BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- CONVERSATIONS
CREATE TABLE IF NOT EXISTS conversations (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  family_id BIGINT REFERENCES families(id) ON DELETE CASCADE,
  title TEXT,
  last_message TEXT,
  last_message_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  unread_count INTEGER DEFAULT 0,
  pinned BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- MESSAGES
CREATE TABLE IF NOT EXISTS messages (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  conversation_id BIGINT REFERENCES conversations(id) ON DELETE CASCADE,
  sender_id UUID REFERENCES auth.users(id), -- Null if sent by family member (if they don't have auth users yet)
  sender_name TEXT, -- Fallback for display
  content TEXT NOT NULL,
  read BOOLEAN DEFAULT FALSE,
  is_own BOOLEAN DEFAULT FALSE, -- Helper for the sender
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- TRANSACTIONS
CREATE TABLE IF NOT EXISTS transactions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  advisor_id UUID REFERENCES profiles(id),
  family_id BIGINT REFERENCES families(id),
  amount TEXT, -- Storing as text to keep "+$100" format or numeric? Code uses text with sign.
  status TEXT,
  date TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  description TEXT,
  type TEXT, -- 'income', 'payout', 'fee', 'subscription'
  invoice_id TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- PAYMENT METHODS
CREATE TABLE IF NOT EXISTS payment_methods (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  advisor_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  type TEXT, -- 'card'
  brand TEXT,
  last4 TEXT,
  expiry TEXT,
  is_default BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- BANK ACCOUNTS
CREATE TABLE IF NOT EXISTS bank_accounts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  advisor_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  bank_name TEXT,
  account_type TEXT,
  last4 TEXT,
  is_default BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- TEAM MEMBERS
CREATE TABLE IF NOT EXISTS team_members (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  advisor_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  email TEXT NOT NULL,
  role TEXT DEFAULT 'member', -- 'admin', 'member', 'viewer'
  status TEXT DEFAULT 'pending', -- 'active', 'pending', 'inactive'
  avatar_url TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- SUBSCRIPTIONS
CREATE TABLE IF NOT EXISTS subscriptions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  advisor_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  plan_id TEXT NOT NULL, -- 'starter', 'professional', 'enterprise'
  status TEXT DEFAULT 'active', -- 'active', 'cancelled', 'past_due'
  current_period_start TIMESTAMP WITH TIME ZONE,
  current_period_end TIMESTAMP WITH TIME ZONE,
  stripe_subscription_id TEXT,
  stripe_customer_id TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- FUNCTIONS

-- Function to increment members count
CREATE OR REPLACE FUNCTION increment_members_count(family_id_param BIGINT)
RETURNS void AS $$
BEGIN
  UPDATE families 
  SET members_count = members_count + 1,
      updated_at = NOW()
  WHERE id = family_id_param;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to decrement members count
CREATE OR REPLACE FUNCTION decrement_members_count(family_id_param BIGINT)
RETURNS void AS $$
BEGIN
  UPDATE families 
  SET members_count = GREATEST(0, members_count - 1),
      updated_at = NOW()
  WHERE id = family_id_param;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to auto-update members_count on insert
CREATE OR REPLACE FUNCTION update_members_count_on_insert()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE families 
  SET members_count = members_count + 1,
      updated_at = NOW()
  WHERE id = NEW.family_id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_members_count_insert
AFTER INSERT ON family_members
FOR EACH ROW EXECUTE FUNCTION update_members_count_on_insert();

-- Trigger to auto-update members_count on delete
CREATE OR REPLACE FUNCTION update_members_count_on_delete()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE families 
  SET members_count = GREATEST(0, members_count - 1),
      updated_at = NOW()
  WHERE id = OLD.family_id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_members_count_delete
AFTER DELETE ON family_members
FOR EACH ROW EXECUTE FUNCTION update_members_count_on_delete();

-- Trigger to create profile on user signup
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO profiles (id, email, first_name, last_name)
  VALUES (
    NEW.id,
    NEW.email,
    NEW.raw_user_meta_data->>'first_name',
    NEW.raw_user_meta_data->>'last_name'
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION handle_new_user();

-- RLS POLICIES

-- Profiles
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Public profiles are viewable by everyone" ON profiles;
DROP POLICY IF EXISTS "Users can insert their own profile" ON profiles;
DROP POLICY IF EXISTS "Users can update their own profile" ON profiles;

CREATE POLICY "Users can view their own profile" ON profiles FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Users can insert their own profile" ON profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update their own profile" ON profiles FOR UPDATE USING (auth.uid() = id);

-- Families
ALTER TABLE families ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Advisors can view their families" ON families;
DROP POLICY IF EXISTS "Advisors can insert families" ON families;
DROP POLICY IF EXISTS "Advisors can update their families" ON families;

CREATE POLICY "Advisors can view their families" ON families FOR SELECT USING (auth.uid() = advisor_id);
CREATE POLICY "Advisors can insert families" ON families FOR INSERT WITH CHECK (auth.uid() = advisor_id);
CREATE POLICY "Advisors can update their families" ON families FOR UPDATE USING (auth.uid() = advisor_id);
CREATE POLICY "Advisors can delete their families" ON families FOR DELETE USING (auth.uid() = advisor_id);

-- Family Members
ALTER TABLE family_members ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Advisors can view members of their families" ON family_members;

CREATE POLICY "Advisors can view members of their families" ON family_members FOR SELECT USING (
  EXISTS (SELECT 1 FROM families WHERE families.id = family_members.family_id AND families.advisor_id = auth.uid())
);
CREATE POLICY "Advisors can insert members to their families" ON family_members FOR INSERT WITH CHECK (
  EXISTS (SELECT 1 FROM families WHERE families.id = family_members.family_id AND families.advisor_id = auth.uid())
);
CREATE POLICY "Advisors can update members of their families" ON family_members FOR UPDATE USING (
  EXISTS (SELECT 1 FROM families WHERE families.id = family_members.family_id AND families.advisor_id = auth.uid())
);
CREATE POLICY "Advisors can delete members from their families" ON family_members FOR DELETE USING (
  EXISTS (SELECT 1 FROM families WHERE families.id = family_members.family_id AND families.advisor_id = auth.uid())
);

-- Tasks
ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Advisors can view their tasks" ON tasks;
DROP POLICY IF EXISTS "Advisors can insert tasks" ON tasks;
DROP POLICY IF EXISTS "Advisors can update their tasks" ON tasks;

CREATE POLICY "Advisors can view their tasks" ON tasks FOR SELECT USING (auth.uid() = advisor_id);
CREATE POLICY "Advisors can insert tasks" ON tasks FOR INSERT WITH CHECK (auth.uid() = advisor_id);
CREATE POLICY "Advisors can update their tasks" ON tasks FOR UPDATE USING (auth.uid() = advisor_id);
CREATE POLICY "Advisors can delete their tasks" ON tasks FOR DELETE USING (auth.uid() = advisor_id);

-- Services
ALTER TABLE services ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Advisors can view their services" ON services;

CREATE POLICY "Advisors can view their services" ON services FOR SELECT USING (auth.uid() = advisor_id);
CREATE POLICY "Advisors can insert services" ON services FOR INSERT WITH CHECK (auth.uid() = advisor_id);
CREATE POLICY "Advisors can update their services" ON services FOR UPDATE USING (auth.uid() = advisor_id);
CREATE POLICY "Advisors can delete their services" ON services FOR DELETE USING (auth.uid() = advisor_id);

-- Consultations
ALTER TABLE consultations ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Advisors can view their consultations" ON consultations;

CREATE POLICY "Advisors can view their consultations" ON consultations FOR SELECT USING (auth.uid() = advisor_id);
CREATE POLICY "Advisors can insert consultations" ON consultations FOR INSERT WITH CHECK (auth.uid() = advisor_id);
CREATE POLICY "Advisors can update their consultations" ON consultations FOR UPDATE USING (auth.uid() = advisor_id);
CREATE POLICY "Advisors can delete their consultations" ON consultations FOR DELETE USING (auth.uid() = advisor_id);

-- Consultation Members
ALTER TABLE consultation_members ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Advisors can view consultation members" ON consultation_members;

CREATE POLICY "Advisors can view consultation members" ON consultation_members FOR SELECT USING (
  EXISTS (SELECT 1 FROM consultations WHERE consultations.id = consultation_members.consultation_id AND consultations.advisor_id = auth.uid())
);
CREATE POLICY "Advisors can manage consultation members" ON consultation_members FOR ALL USING (
  EXISTS (SELECT 1 FROM consultations WHERE consultations.id = consultation_members.consultation_id AND consultations.advisor_id = auth.uid())
);

-- Credentials
ALTER TABLE credentials ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Advisors can manage their credentials" ON credentials;

CREATE POLICY "Advisors can manage their credentials" ON credentials FOR ALL USING (auth.uid() = advisor_id);

-- Expertise
ALTER TABLE expertise ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Advisors can manage their expertise" ON expertise;

CREATE POLICY "Advisors can manage their expertise" ON expertise FOR ALL USING (auth.uid() = advisor_id);

-- Notifications
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can view their notifications" ON notifications;
DROP POLICY IF EXISTS "Users can update their notifications" ON notifications;

CREATE POLICY "Users can view their notifications" ON notifications FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their notifications" ON notifications FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their notifications" ON notifications FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their notifications" ON notifications FOR DELETE USING (auth.uid() = user_id);

-- Conversations
ALTER TABLE conversations ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Advisors can view their conversations" ON conversations;

CREATE POLICY "Advisors can view their conversations" ON conversations FOR SELECT USING (
  EXISTS (SELECT 1 FROM families WHERE families.id = conversations.family_id AND families.advisor_id = auth.uid())
);
CREATE POLICY "Advisors can manage their conversations" ON conversations FOR ALL USING (
  EXISTS (SELECT 1 FROM families WHERE families.id = conversations.family_id AND families.advisor_id = auth.uid())
);

-- Messages
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Advisors can view messages in their conversations" ON messages;
DROP POLICY IF EXISTS "Advisors can insert messages" ON messages;

CREATE POLICY "Advisors can view messages in their conversations" ON messages FOR SELECT USING (
  EXISTS (SELECT 1 FROM conversations JOIN families ON families.id = conversations.family_id WHERE conversations.id = messages.conversation_id AND families.advisor_id = auth.uid())
);
CREATE POLICY "Advisors can insert messages" ON messages FOR INSERT WITH CHECK (
  EXISTS (SELECT 1 FROM conversations JOIN families ON families.id = conversations.family_id WHERE conversations.id = messages.conversation_id AND families.advisor_id = auth.uid())
);
CREATE POLICY "Advisors can update messages" ON messages FOR UPDATE USING (
  EXISTS (SELECT 1 FROM conversations JOIN families ON families.id = conversations.family_id WHERE conversations.id = messages.conversation_id AND families.advisor_id = auth.uid())
);

-- Transactions
ALTER TABLE transactions ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Advisors can view their transactions" ON transactions;

CREATE POLICY "Advisors can view their transactions" ON transactions FOR SELECT USING (auth.uid() = advisor_id);
CREATE POLICY "Advisors can insert transactions" ON transactions FOR INSERT WITH CHECK (auth.uid() = advisor_id);

-- Payment Methods
ALTER TABLE payment_methods ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Advisors can manage their payment methods" ON payment_methods;

CREATE POLICY "Advisors can manage their payment methods" ON payment_methods FOR ALL USING (auth.uid() = advisor_id);

-- Bank Accounts
ALTER TABLE bank_accounts ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Advisors can manage their bank accounts" ON bank_accounts;

CREATE POLICY "Advisors can manage their bank accounts" ON bank_accounts FOR ALL USING (auth.uid() = advisor_id);

-- Team Members
ALTER TABLE team_members ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Advisors can manage their team" ON team_members FOR ALL USING (auth.uid() = advisor_id);

-- Subscriptions
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Advisors can view their subscription" ON subscriptions FOR SELECT USING (auth.uid() = advisor_id);
CREATE POLICY "Advisors can manage their subscription" ON subscriptions FOR ALL USING (auth.uid() = advisor_id);

-- Enable Realtime for messages and notifications
ALTER PUBLICATION supabase_realtime ADD TABLE messages;
ALTER PUBLICATION supabase_realtime ADD TABLE notifications;
ALTER PUBLICATION supabase_realtime ADD TABLE conversations;

